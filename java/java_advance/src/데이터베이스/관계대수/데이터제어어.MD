### DML 데이터 제어어(Data Manipulation language)

```jql
/*키워드 정리
테이블을 복사하는 SELECT
CREATE TABLE 테이블 이름(SELECT 원하는 속성 지정 FROM 기존 테이블)
create table buytb12 (select * from buytbl);
*/ 

-- 아래 쿼리문은 기존에 테이블에서 추출해서 새로운 테이블을 만든것이다. 
select * from buytbl;
create table buytb12 (select * from buytbl);
create table buytbl3 (select num,userID,prodName from buytbl);
desc buytb12; -- 이것은 오류가 뜬다 키값을 설정을 따로 안해주었기 때문에 





```

<details>
<summary>Group by 절과 having , 집계 함수    </summary>
<div markdown="1">

- Group 절을 이해해야 Join을 이해할 수 있다. 
- Group by절은 투플별로 그룹핑을 한다.
- 그룹바이절이 있으면  유저별로 출력이 되고
- 그룹바이절이 없으면 총 평균이 나온다.
````jql
 -- 1. buytbl 테이블에서 사용자아이디와 재고수량을 아이디 오름차순 정렬하여 출력 
 select userid, amount from buytbl order by userid asc;
 
 select sum(amount) as 총개수 from buytbl group by userid; -- 이게 무슨의미지? 
 
 -- 2.전체 구매자가 구매한 물품의 평균을 구하여 출력하세요.
 select userID, (amount) as '구매 물품 평균' from buytbl group by userid;
 select userid, avg(amount) as '구매 물품 평균' from buytbl;
 select userid, prodname, avg(amount) from buytbl group by userid,prodname; -- 이것은 오류가 난다.
 select * from buytbl;
 /*
 그룹바이절이 있으면  유저별로 출력이 되고 
 그룹바이절이 없으면 총 평균이 나온다. */
 가장 큰 키와 가장 칸은 키의 회원의 이름과 키를 출력해라 
 select name max(height), min(height) from usertbl group by name;
 select name, height from usertbl 
where 
height = (select max(height) from usertbl)
 or 
 height = (select min(height) from usertbl);
 
 -- 3. 휴대폰이 있는 사용자의 수를 출력하세요 : count();
 select * from usertbl;

 select count(*) from usertbl; -- 전체 튜플 카운트

select count(mobile2) from usertbl; -- 지정한 칼럼 수 카운트 단 null 제외 
 

````

<details>
<summary> having 절 </summary>
<div markdown="1">



```jql
-- group by의 조건 having 


-- 1. 사용자 별 총 구매액 출력 buytbl
select * from buytbl;
select userid as '사용자',sum(price*amount) as '총구매액'
from buytbl
group by userid;

-- 2. 총 구매액이 1000 이상인 사용자에게만 사은품 증정 하려고 한다.  
select * from buytbl;


select userid as '사용자',sum(price*amount) as '총구매액'
from buytbl
where sum(price*amount)>1000
group by userid;
-- 이것은 오류가 뜬다 왜? where절에는 집계함수가 들어갈 수가 없다.


select userid as '사용자',sum(price*amount) as '총구매액'
from buytbl
group by userid
having sum(price*amount)>1000;
-- 이게 정답이다.

----------------------------------------------------

-- 1.총 구매액이 1000 이상인 사용자에게만 사은 품 증정 하려고 한다. 이 조건에서 해당하는 사용자 아이디와 총 구매액을 총 구매액이 적은 순으로 출력
select userid as '사용자',sum(price*amount) "총구매액"
from buytbl
group by userid
having sum(price*amount) >1000
order by sum(price*amount);

-- 총합 또는 중가합계를 구하려면 group by절과 함께 ROLLUP문을 함께 사용한다.


-- GROUPNAME(분류) 별로 합계와 그 총합을 구하고 싶다.
SELECT GROUPNAME FROM buytbl;

select num, groupname, sum(price*amount) as 비용 from buytbl group by groupname, num with rollup;
-- rollup 키워드


/*@@@롤업 키워드 @@@
ROLLUP함수는 소그룹간의 합계를 계산하는 함수입니다.
ROLLUP을 사용하면 GROUP BY로 묶은 각각의 소그룹 합계와 전체 합계를 모두 구할 수 있습니다.


```
</div>
</details>

</div>
</details>

<details>
<summary> 트렌젝션 제어어 </summary>
<div markdown="1">

- 테이블의 데이터를 변경(입력/수정/삭제)할때 실제 테이블에 완전히 적용하지 않고, 임시로 적용시키는 것. 실수가 있을 경우 취소할 수 있다.

```jql
-- 트렌젝션제어어 테이블의 데이터를 변경(입력/수정/삭제)할때 실제 테이블에 완전히 적용하지 않고, 임시로 적용시키는 것. 실수가 있을 경우 취소할 수 있다.
*/
SELECT * FROM usertbl;
DESC usertbl;
INSERT INTO usertbl VALUES ('sym', 'yoomi', 2000, '경기', '010', '12345878', 170, '2024-01-17');
ROLLBACK;
DELETE FROM usertbl where userid = 'sym';
SELECT * FROM usertbl;


-- test 테이블 생성 @@@@@
create table testtbl(
id int,
username char(3),
age int);
insert into testtbl values(3,'문석',34);
select * from testtbl;
rollback;


insert into testtbl(id,username) values(2,"kko");
insert into testtbl(username,id,age) values('jko',3,22);
select * from testtbl;



```

</div>
</details>

<details>
<summary> Autoincrement </summary>
<div markdown="1">

```jql
-- test2테이블 생성 @@@@@
create table testtbl2(
id int auto_increment primary key, username char(3), age int); -- auto_increment +1 씩 증가해주는것이다 
insert into testtbl2 values(null,'지효',25);
select * from testtbl2;
rollback;
commit; -- 커밋후에는 롤백이 되지 않는다. 

select @@autocommit;
set autocommit =0;

==================================

-- autoincrement 어느 숫자까지 증가되었는지 확인방법 
select last_insert_id();
alter table testtbl2 auto_increment = 100; -- auto_increment 입력값을 100부터 입력되도록 변경하겠다.
set @@auto_increment_increment =3;

insert into testtbl2 values(null,'oj1',5);
insert into testtbl2 values(null,'oj2',10);
select * from testtbl2;

```

</div>
</details>

<details>
<summary> Update,Delete,Turncate,Update set </summary>
<div markdown="1">

```jql

-- 대량의 샘플데이터 생성 방법 : insert into ...select 구문 
-- testtbl3 테이블 생성한 후 데이터 받아오기 
create table testtbl3 (
id int,
fname varchar(50),
lname varchar(50));
insert into testtbl3 select emp_no,first_name,
last_name from employees.employees;
select
 count(id) from testtbl3;
 -- 
 commit;
 
 -- testtbl4 employees.employees 테이블 속성중 emp_no, first_name, last_name 한번에 받아오기 
 create table testtbl4(select emp_no, first_name, last_name from employees.employees);
 desc testtbl4;
 
 -- 데이터의 수정 : update : 기존에 입력되어 있는 값을 변경하기 위해 사용하는 명령어 
 update 테이블 이름 
 set 열1 = 값1, 열2 =값2
 where 조건; -- 생략 가능 
 
 select * from testtbl4;
 update testtbl4
 set last_name = 'none'
 where first_name = 'kyoichi';
rollback;
 select * from testtbl4;
commit;
-- 데이터의 삭제 : DELETE FROM 테이블이름 WHERE 조건;  (투플에 대한 삭제) // 단위가 투플이라고생각해라 (행,ROW,TUPLE 단위) 
SELECT last_name
from testtbl4;
delete from testtbl4 where last_name = 'lamba';
delete from testtbl4 where last_name = 'lamba' limit 5;
rollback;

-- 대용량 테이블 3개 생성 bigtbl1, bigtabl2, bigtabl3 을 하고 테이블을 삭제하려면 
-- 3개 테이블 생성 
create table bigtbl1(select emp_no,birth_date, first_name, last_name,gender,hire_date from employees.employees);
create table bigtbl2(select emp_no,birth_date, first_name, last_name,gender,hire_date from employees.employees);
create table bigtbl3(select emp_no,birth_date, first_name, last_name,gender,hire_date from employees.employees);
-- create table bigtbl1(select * from employees.employees); 이렇게 가능 
-- 테이블 삭제 
delete from bigtbl1; -- bigtbl1 전체 튜플만 삭제 
drop table bigtbl1; -- bigtbl1 테이블 자체를 삭제
truncate table bigtbl3; -- 트렌젝션 로그를 기록하지 않고 투플만 삭제 delete와의 차이는 속도가 더 빠르다   

```


</div>
</details>
